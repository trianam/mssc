
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

\documentclass[a4paper,twosides]{report}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{microtype}
\usepackage{acronym}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[hidelinks,breaklinks=true]{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{stmaryrd}

\newcommand{\betaReduction}{\ensuremath{\longrightarrow_{\beta}}}
\newcommand{\betaReductionS}{\ensuremath{\Longrightarrow_{\beta}}}

\author{
  {\Large Stefano Martina}\\
  {\small stefano.martina@stud.unifi.it}\\
  Universit\`a degli Studi di Firenze\\
  Scuola di Scienze Matematiche, Fisiche e Naturali\\
  Corso magistrale di Informatica
}
\title{{\Huge\bfseries Modelli di Sistemi Sequenziali e
    Concorrenti}\\{\large\bfseries esercizi}}

\begin{document}
\maketitle

\section*{3.15}

\section*{4.11}

\section*{5.5}
\paragraph{Esercizio:}
Dati:
\begin{eqnarray*}
  \mathbf{S}&\equiv&\lambda xyz.xz(yz)\\
  \mathbf{K}&\equiv&\lambda xy.x\\
  \mathbf{I}&\equiv&\lambda x.x
\end{eqnarray*}
mostrare che $\mathbf{SK}=\mathbf{KI}$.
\paragraph{Soluzione:}
Valgono i passaggi:
\begin{eqnarray*}
  \mathbf{SK}&=&(\lambda xyz.xz(yz))(\lambda xy.x)\\
  &\betaReduction&\lambda yz.(\lambda xy.x)z(yz)\\
  &\betaReduction&\lambda yz.(\lambda y.z)(yz)\\
  &\betaReduction&\lambda yz.z\\
  &\equiv&\lambda xy.y
\end{eqnarray*}
e anche:
\begin{eqnarray*}
  \mathbf{KI}&=&(\lambda xy.x)(\lambda x.x)\\
  &\betaReduction&\lambda y.(\lambda x.x)\\
  &\equiv&\lambda yx.x\\
  &\equiv&\lambda xy.y\\
\end{eqnarray*}
quindi la tesi \`e dimostrata perch\`e i due termini riducono alla
stessa forma. 
\section*{6.10}
\paragraph{Esercizio:}
Sia $D$ un cpo. Una funzione $r : D \rightarrow D$ si dice idempotente
se $r(r(x)) = r(x)$, per ogni $x \in D$.
Dimostrare che l’insieme di tutte le funzioni continue idempotenti da
$D$ in $D$ è un cpo.
\paragraph{Soluzione:}
Poich\'e $D$ \`e un cpo, lo spazio delle funzioni continue da $D$ a
$D$ denotato da $[D\rightarrow D] = (D\rightarrow D, \sqsubseteq)$,
cos\`i come in definizione 6.33, \`e un cpo. L'insieme delle funzioni
continue e idempotenti $G$ \`e un sottoinsieme dell'insieme delle funzioni
continue $D\rightarrow D$, quindi considerando $\sqsubseteq_G$ la
restrizione di $\sqsubseteq$ a $G$, si ha che $\mathbb{G} = (G,\sqsubseteq_G)$ \`e
un poset. Per dimostrare che $\mathbb{G}$ \`e anche un cpo \`e
necessario mostrare che con la restrizione da $[D\rightarrow D]$ a
$\mathbb{G}$ vengono mantenuti il minimo (punto 1) e i $\sup$ di ogni
catena in $\mathbb{G}$ (punto 2).
\begin{enumerate}
\item Il minimo di $[D\rightarrow D]$ \`e $\Omega\equiv\lambda
  x.\perp_D$ con $\perp_D$ il minimo di $D$. Tale funzione \`e anche
  idempotente perch\'e $\Omega(x)=\Omega(\Omega(x))=\perp_D$ per
  qualunque $x$, quindi appartiene anche a $G$.
\item Data una generica catena di funzioni continue e idempotenti
  $\{f_i|i\in I\}$, \`e necessario dimostrare che il $\sup$ di tale
  catena, che sappiamo dalla dimostrazione del teorema 6.34 essere:
  $$g\equiv\lambda x.\sup\{ f_i x|i\in I\}$$
  sia $\in G$ e quindi idempotente, e quindi che $g(g x)=g(x)$ per
  ogni $x$.

  La dimostrazione procede nel seguente modo:
  \begin{eqnarray*}
    g(g x)&=&(\lambda x'.\sup\{f_i x'|i\in I\})((\lambda x''.\sup\{f_i x''|i\in I\})x)\\
    &=&(\lambda x'.\sup\{f_i x'|i\in I\})\sup\{f_i x|i\in I\}\\
    &=&\sup\{f_i (\sup\{f_j x|j\in I\})|i\in I\}
  \end{eqnarray*}
  e per la continuit\`a delle $f_i$
  \begin{eqnarray*}
    &=&\sup\{\sup\{f_i (f_j x)|j\in I\}|i\in I\}
  \end{eqnarray*}
  a questo punto disponendo in forma matriciale ordinata gli $f_i$ e
  gli $f_j$ \`e possibile applicare la proposizione 6.27(2) e si
  ottiene
  \begin{eqnarray*}
    &=&\sup\{f_i(f_i x)|i\in I\}
  \end{eqnarray*}
  e poich\'e tutte le $f_i$ sono idempotenti
  \begin{eqnarray*}
    &=&\sup\{f_i x|i\in I\}\\
    &=&g x
  \end{eqnarray*}
  \qed
\end{enumerate}

\section*{7.6}
\paragraph{Esercizio:}
Fornire semantica operazionale e denotazionale del programma
$$
\mathbf{letrec} f(x) \Leftarrow f(x) \mathbf{in} f(5)  
$$

\paragraph{Soluzione:}
Cominciando con la semantica operazionale con chiamata per nome si ha:
$$
f(5) \xrightarrow{(FUN)}_D f(5) \xrightarrow{(FUN)}_D \dots
$$
e in modo simile per quella con chiamata per valore usando
$(FUN')$. Quindi divergono.

Per la semantica denotazionale, usando un approccio bottom up, si ha:
\begin{eqnarray*}
  \mathcal{T}[[5]]&=&\lambda f.\lambda x. 5\\
  \mathcal{T}[[x]]&=&\lambda f.\lambda x. x\\
  \mathcal{T}[[f(5)]]&=&\lambda f.\lambda x. f(\mathcal{T}[[5]]fx)\\
  &=&\lambda f.\lambda x.f(5)\\
  \mathcal{T}[[f(x)]]&=&\lambda f.\lambda x. f(\mathcal{T}[[x]]fx)\\
  &=&\lambda f.\lambda x.f((\lambda f.\lambda x'.x')fx)\\
  &=&\lambda f.\lambda x.f(x)\\
  \mathcal{D}[[f(x)\Leftarrow f(x)]]&=&fix(\lambda
  f.\mathcal{T}[[f(x)]]f)\\
  &=&fix(\lambda f.(\lambda f'.\lambda x.f'(x))f)\\
  &=&fix(\lambda f.\lambda x. f(x))\\
  &=&\lambda x.\perp\\
  &=&\Omega\\
  \mathcal{P}[[\mathbf{letrec} f(x) \Leftarrow f(x) \mathbf{in} f(5)
  ]]&=&\mathcal{T}[[f(5)]]\mathcal{D}[[f(x)\Leftarrow f(x)]]0\\
  &=&(\lambda f.\lambda x.f(5))\Omega 0\\
  &=&\Omega 5\\
  &=&\perp
\end{eqnarray*}

Dalla valutazione della semantica operazionale si nota che il
programma diverge, e infatti
la valutazione della semantica denotazionale lo conferma restituendo, come
prevedibile, un risultato non definito.
\section*{8.11}
\paragraph{Esercizio:} Si aggiunga al linguaggio TINY un comando $\mathbf{stop}$
con la semantica informale di far terminare il 
programma. Se ne dia la semantica e si dimostri che $c 1 ; \mathbf{stop}$ e $c 1 ;
\mathbf{stop}; c 2$ sono semanticamente
equivalenti.

\paragraph{Soluzione:}
\`E possibile estendere la semantica operazionale in modo da gestire
lo $\mathbf{stop}$ modificando leggermente $(\text{Seq}_2)$ in:
$$
\frac{<c_1,\sigma>\ \longrightarrow\ <c_1',\sigma'>}{<c_1;c_2,\sigma>\
  \longrightarrow\ <c_1';c_2,\sigma'>}(c_1'\neq\mathbf{stop})\qquad (\text{Seq}_2')
$$
e aggiungendo le due regole
\begin{align*}
<\mathbf{stop},\sigma>&\longrightarrow{} <\mathbf{noaction},\sigma>&(\text{Stop}_1)\\
<\mathbf{stop};c,\sigma>&\longrightarrow{} <\mathbf{stop},\sigma>&(\text{Stop}_2)
\end{align*}

Per quanto riguarda la semantica denotazionale \`e pi\`u difficile
ottenere lo stesso risultato. \`E necessario cambiare anche il dominio
delle funzioni di interpretazione semantica dei comandi in:
$$
\mathcal{C}: Com\longrightarrow{}\mathbb{STATO}\longrightarrow{}(\mathbb{STATO}+(\mathbb{STATO}\times\{stop\})+\{error\})
$$
per aggiungere la possibilit\`a che la computazione ritorni una coppia
$<\sigma,stop>$ che va letta come lo stato $\sigma$ con
l'aggiunta dell'informazione che la computazione \`e terminata a causa
di un comando $\mathbf{stop}$. Va quindi modificata la denotazione
corrispondente alla sequenzializzazione di comandi in:
\begin{align*}
  \mathcal{C}\llbracket c_1;c_2\rrbracket&= \lambda\sigma.cases (\mathcal{C}\llbracket c_1\rrbracket\sigma)
  of\\
&\qquad\qquad\sigma':\mathcal{C}\llbracket c_2\rrbracket\sigma',\\
&\qquad\qquad<\sigma',stop>:<\sigma',stop>,\\
&\qquad\qquad error : error;\\
&\qquad endcases
\end{align*}
e aggiunta la denotazione per lo $\mathbf{stop}$:
$$
\mathcal{C}\llbracket\mathbf{stop}\rrbracket=\lambda\sigma.<\sigma,\mathbf{stop}>
$$
Con queste aggiunte andrebbero anche riviste e  modificate la dimostrazione di
equivalenza tra le due semantiche e la formalizzazione in punto fisso della
denotazione del $\mathbf{while}$ che fa uso della
sequenzializzazione. Queste ultime modifiche vengono tralasciate
perch\'e non inerenti all'esercizio.

Per dimostrare che $c_1;\mathbf{stop}$ e $c_1;\mathbf{stop};c_2$ sono
semanticamente equivalenti, si pu\`o usare la semantica operazionale
per mostrare che le computazioni dei due programmi portano a
configurazioni finali con stati identici, dato
un qualsiasi
stato iniziale $\sigma$.
Per $c_1;\mathbf{stop}$ vale che:
\begin{gather*}
  <c_1;stop,\sigma>\\
  \downarrow_{(\text{Seq}_2')}\\
  <stop,\sigma'>\\
  \downarrow_{(\text{Stop}_1)}\\
  <noaction,\sigma'>\\
\end{gather*}
dove \`e stata usata l'istanza di $(\text{Seq}_2')$:
$$
\frac{<c_1,\sigma> \longrightarrow{}
  <c_1',\sigma'>}{<c_1;\mathbf{stop},\sigma> \longrightarrow{}
  <\mathbf{stop},\sigma'>}
$$

Per $c_1;\mathbf{stop};c_2$ vale che:
\begin{gather*}
  <c_1;stop;c_2,\sigma>\\
  \downarrow_{(\text{Seq}_2')}\\
  <stop;c_2,\sigma'>\\
  \downarrow_{(\text{Stop}_2)}\\
  <stop,\sigma'>\\
  \downarrow_{(\text{Stop}_1)}\\
  <noaction,\sigma'>\\
\end{gather*}
dove \`e stata usata l'istanza di $(\text{Seq}_2')$:
$$
\frac{<c_1,\sigma> \longrightarrow{}
  <c_1',\sigma'>}{<c_1;\mathbf{stop};c_2,\sigma> \longrightarrow{}
  <\mathbf{stop};c_2,\sigma'>}
$$
con $c_1'$ e $\sigma'$ gli stessi di prima in quanto la premessa è la
stessa. Quindi poich\'e entrambe le computazioni hanno lo stesso stato
finale $<\mathbf{noaction},\sigma'>$, la tesi
\`e vera.

\`E possibile anche dimostrare l'equivalenza usando la semantica
denotazionale, osservando che sia nella denotazione di $\mathcal{C}\llbracket
c_1;\mathbf{stop}\rrbracket$ che in quella di $\mathcal{C}\llbracket
c_1;\mathbf{stop};c_2\rrbracket$ viene prima valutato $\mathcal{C}\llbracket
c_1\rrbracket$ e poi applicato $\sigma'$ a $\mathcal{C}\llbracket
\mathbf{stop}\rrbracket$ in un caso e $\mathcal{C}\llbracket
\mathbf{stop};c_2\rrbracket$ nell'altro. In seguito l'unica differenza
\`e che nel primo caso vale subito che $\mathcal{C}\llbracket
\mathbf{stop}\rrbracket\sigma'$ \`e $<\sigma',stop>$, nel secondo caso
c'è un ulteriore passaggio in cui viene usato il secondo \emph{case}
della denotazione della sequenzializzazione e che per\`o non cambia il
risultato.


\section*{9.7}

\section*{11.10}

\section*{12.1}

\section*{12.2}
 
\end{document}

