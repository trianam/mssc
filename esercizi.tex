
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

\documentclass[a4paper,twosides]{report}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{microtype}
\usepackage{acronym}
\usepackage[fleqn]{mathtools}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{xcolor}
%\usepackage[hidelinks,breaklinks=true]{hyperref}
\usepackage{listings}
\usepackage{stmaryrd}
%\usepackage{ornament}
\usepackage{tikz}
\usepackage[fleqn]{amsmath}

\newcommand{\betaReduction}{\ensuremath{\longrightarrow_{\beta}}}
\newcommand{\betaReductionS}{\ensuremath{\Longrightarrow_{\beta}}}

% \newcommand{\sectionline}{
%   \begin{center}
%     \resizebox{0.5\linewidth}{1ex}{
%       \begin{tikzpicture}
%         \node  (C) at (0,0) {};
%         \node (D) at (9,0) {};
%         \path (C) to [ornament=83] (D);
%       \end{tikzpicture}
%     }
%   \end{center}
% }

\author{
  {\Large Stefano Martina}\\
  {\small stefano.martina@stud.unifi.it}\\
  Universit\`a degli Studi di Firenze\\
  Scuola di Scienze Matematiche, Fisiche e Naturali\\
  Corso magistrale di Informatica
}
\title{{\Huge\bfseries Modelli di Sistemi Sequenziali e
    Concorrenti}\\{\large\bfseries esercizi}}

\begin{document}
\maketitle

\section*{3.15}

\section*{4.11}

\section*{5.5}
\paragraph{Esercizio:}
Dati:
\begin{eqnarray*}
  \mathbf{S}&\equiv&\lambda xyz.xz(yz)\\
  \mathbf{K}&\equiv&\lambda xy.x\\
  \mathbf{I}&\equiv&\lambda x.x
\end{eqnarray*}
mostrare che $\mathbf{SK}=\mathbf{KI}$.
\paragraph{Soluzione:}
Valgono i passaggi:
\begin{eqnarray*}
  \mathbf{SK}&=&(\lambda xyz.xz(yz))(\lambda xy.x)\\
  &\betaReduction&\lambda yz.(\lambda xy.x)z(yz)\\
  &\betaReduction&\lambda yz.(\lambda y.z)(yz)\\
  &\betaReduction&\lambda yz.z\\
  &\equiv&\lambda xy.y
\end{eqnarray*}
e anche:
\begin{eqnarray*}
  \mathbf{KI}&=&(\lambda xy.x)(\lambda x.x)\\
  &\betaReduction&\lambda y.(\lambda x.x)\\
  &\equiv&\lambda yx.x\\
  &\equiv&\lambda xy.y\\
\end{eqnarray*}
quindi la tesi \`e dimostrata perch\`e i due termini riducono alla
stessa forma. 
\section*{6.10}
\paragraph{Esercizio:}
Sia $D$ un cpo. Una funzione $r : D \rightarrow D$ si dice idempotente
se $r(r(x)) = r(x)$, per ogni $x \in D$.
Dimostrare che l’insieme di tutte le funzioni continue idempotenti da
$D$ in $D$ è un cpo.
\paragraph{Soluzione:}
Poich\'e $D$ \`e un cpo, lo spazio delle funzioni continue da $D$ a
$D$ denotato da $[D\rightarrow D] = (D\rightarrow D, \sqsubseteq)$,
cos\`i come in definizione 6.33, \`e un cpo. L'insieme delle funzioni
continue e idempotenti $G$ \`e un sottoinsieme dell'insieme delle funzioni
continue $D\rightarrow D$, quindi considerando $\sqsubseteq_G$ la
restrizione di $\sqsubseteq$ a $G$, si ha che $\mathbb{G} = (G,\sqsubseteq_G)$ \`e
un poset. Per dimostrare che $\mathbb{G}$ \`e anche un cpo \`e
necessario mostrare che con la restrizione da $[D\rightarrow D]$ a
$\mathbb{G}$ vengono mantenuti il minimo (punto 1) e i $\sup$ di ogni
catena in $\mathbb{G}$ (punto 2).
\begin{enumerate}
\item Il minimo di $[D\rightarrow D]$ \`e $\Omega\equiv\lambda
  x.\perp_D$ con $\perp_D$ il minimo di $D$. Tale funzione \`e anche
  idempotente perch\'e $\Omega(x)=\Omega(\Omega(x))=\perp_D$ per
  qualunque $x$, quindi appartiene anche a $G$.
\item Data una generica catena di funzioni continue e idempotenti
  $\{f_i|i\in I\}$, \`e necessario dimostrare che il $\sup$ di tale
  catena, che sappiamo dalla dimostrazione del teorema 6.34 essere:
  $$g\equiv\lambda x.\sup\{ f_i x|i\in I\}$$
  sia $\in G$ e quindi idempotente, e quindi che $g(g x)=g(x)$ per
  ogni $x$.

  La dimostrazione procede nel seguente modo:
  \begin{eqnarray*}
    g(g x)&=&(\lambda x'.\sup\{f_i x'|i\in I\})((\lambda x''.\sup\{f_i x''|i\in I\})x)\\
    &=&(\lambda x'.\sup\{f_i x'|i\in I\})\sup\{f_i x|i\in I\}\\
    &=&\sup\{f_i (\sup\{f_j x|j\in I\})|i\in I\}
  \end{eqnarray*}
  e per la continuit\`a delle $f_i$
  \begin{eqnarray*}
    &=&\sup\{\sup\{f_i (f_j x)|j\in I\}|i\in I\}
  \end{eqnarray*}
  a questo punto disponendo in forma matriciale ordinata gli $f_i$ e
  gli $f_j$ \`e possibile applicare la proposizione 6.27(2) e si
  ottiene
  \begin{eqnarray*}
    &=&\sup\{f_i(f_i x)|i\in I\}
  \end{eqnarray*}
  e poich\'e tutte le $f_i$ sono idempotenti
  \begin{eqnarray*}
    &=&\sup\{f_i x|i\in I\}\\
    &=&g x
  \end{eqnarray*}
  \qed
\end{enumerate}

\section*{7.6}
\paragraph{Esercizio:}
Fornire semantica operazionale e denotazionale del programma
$$
\mathbf{letrec} f(x) \Leftarrow f(x) \mathbf{in} f(5)  
$$

\paragraph{Soluzione:}
Cominciando con la semantica operazionale con chiamata per nome si ha:
$$
f(5) \xrightarrow{(FUN)}_D f(5) \xrightarrow{(FUN)}_D \dots
$$
e in modo simile per quella con chiamata per valore usando
$(FUN')$. Quindi divergono.

Per la semantica denotazionale, usando un approccio bottom up, si ha:
\begin{eqnarray*}
  \mathcal{T}[[5]]&=&\lambda f.\lambda x. 5\\
  \mathcal{T}[[x]]&=&\lambda f.\lambda x. x\\
  \mathcal{T}[[f(5)]]&=&\lambda f.\lambda x. f(\mathcal{T}[[5]]fx)\\
  &=&\lambda f.\lambda x.f(5)\\
  \mathcal{T}[[f(x)]]&=&\lambda f.\lambda x. f(\mathcal{T}[[x]]fx)\\
  &=&\lambda f.\lambda x.f((\lambda f.\lambda x'.x')fx)\\
  &=&\lambda f.\lambda x.f(x)\\
  \mathcal{D}[[f(x)\Leftarrow f(x)]]&=&fix(\lambda
  f.\mathcal{T}[[f(x)]]f)\\
  &=&fix(\lambda f.(\lambda f'.\lambda x.f'(x))f)\\
  &=&fix(\lambda f.\lambda x. f(x))\\
  &=&\lambda x.\perp\\
  &=&\Omega\\
  \mathcal{P}[[\mathbf{letrec} f(x) \Leftarrow f(x) \mathbf{in} f(5)
  ]]&=&\mathcal{T}[[f(5)]]\mathcal{D}[[f(x)\Leftarrow f(x)]]0\\
  &=&(\lambda f.\lambda x.f(5))\Omega 0\\
  &=&\Omega 5\\
  &=&\perp
\end{eqnarray*}

Dalla valutazione della semantica operazionale si nota che il
programma diverge, e infatti
la valutazione della semantica denotazionale lo conferma restituendo, come
prevedibile, un risultato non definito.
\section*{8.11}
\paragraph{Esercizio:} Si aggiunga al linguaggio TINY un comando $\mathbf{stop}$
con la semantica informale di far terminare il 
programma. Se ne dia la semantica e si dimostri che $c 1 ; \mathbf{stop}$ e $c 1 ;
\mathbf{stop}; c 2$ sono semanticamente
equivalenti.

\paragraph{Soluzione:}
\`E possibile estendere la semantica operazionale in modo da gestire
lo $\mathbf{stop}$ modificando leggermente $(\text{Seq}_2)$ in:
$$
\frac{<c_1,\sigma>\ \longrightarrow\ <c_1',\sigma'>}{<c_1;c_2,\sigma>\
  \longrightarrow\ <c_1';c_2,\sigma'>}(c_1'\neq\mathbf{stop})\qquad (\text{Seq}_2')
$$
e aggiungendo le due regole
\begin{align*}
<\mathbf{stop},\sigma>&\longrightarrow{} <\mathbf{noaction},\sigma>&(\text{Stop}_1)\\
<\mathbf{stop};c,\sigma>&\longrightarrow{} <\mathbf{stop},\sigma>&(\text{Stop}_2)
\end{align*}

Per quanto riguarda la semantica denotazionale \`e pi\`u difficile
ottenere lo stesso risultato. \`E necessario cambiare anche il dominio
delle funzioni di interpretazione semantica dei comandi in:
$$
\mathcal{C}: Com\longrightarrow{}\mathbb{STATO}\longrightarrow{}(\mathbb{STATO}+(\mathbb{STATO}\times\{stop\})+\{error\})
$$
per aggiungere la possibilit\`a che la computazione ritorni una coppia
$<\sigma,stop>$ che va letta come lo stato $\sigma$ con
l'aggiunta dell'informazione che la computazione \`e terminata a causa
di un comando $\mathbf{stop}$. Va quindi modificata la denotazione
corrispondente alla sequenzializzazione di comandi in:
\begin{align*}
  \mathcal{C}\llbracket c_1;c_2\rrbracket&= \lambda\sigma.cases (\mathcal{C}\llbracket c_1\rrbracket\sigma)
  of\\
&\qquad\qquad\sigma':\mathcal{C}\llbracket c_2\rrbracket\sigma';\\
&\qquad\qquad<\sigma',stop>:<\sigma',stop>;\\
&\qquad\qquad error : error\\
&\qquad endcases
\end{align*}
e aggiunta la denotazione per lo $\mathbf{stop}$:
$$
\mathcal{C}\llbracket\mathbf{stop}\rrbracket=\lambda\sigma.<\sigma,\mathbf{stop}>
$$
Con queste aggiunte andrebbero anche riviste e  modificate la dimostrazione di
equivalenza tra le due semantiche e la formalizzazione in punto fisso della
denotazione del $\mathbf{while}$ che fa uso della
sequenzializzazione. Queste ultime modifiche vengono tralasciate
perch\'e non inerenti all'esercizio.

Per dimostrare che $c_1;\mathbf{stop}$ e $c_1;\mathbf{stop};c_2$ sono
semanticamente equivalenti, si pu\`o usare la semantica operazionale
per mostrare che le computazioni dei due programmi portano a
configurazioni finali con stati identici, dato
un qualsiasi
stato iniziale $\sigma$.
Per $c_1;\mathbf{stop}$ vale che:
\begin{gather*}
  <c_1;stop,\sigma>\\
  \downarrow_{(\text{Seq}_2')}\\
  <stop,\sigma'>\\
  \downarrow_{(\text{Stop}_1)}\\
  <noaction,\sigma'>\\
\end{gather*}
dove \`e stata usata l'istanza di $(\text{Seq}_2')$:
$$
\frac{<c_1,\sigma> \longrightarrow{}
  <c_1',\sigma'>}{<c_1;\mathbf{stop},\sigma> \longrightarrow{}
  <\mathbf{stop},\sigma'>}
$$

Per $c_1;\mathbf{stop};c_2$ vale che:
\begin{gather*}
  <c_1;stop;c_2,\sigma>\\
  \downarrow_{(\text{Seq}_2')}\\
  <stop;c_2,\sigma'>\\
  \downarrow_{(\text{Stop}_2)}\\
  <stop,\sigma'>\\
  \downarrow_{(\text{Stop}_1)}\\
  <noaction,\sigma'>\\
\end{gather*}
dove \`e stata usata l'istanza di $(\text{Seq}_2')$:
$$
\frac{<c_1,\sigma> \longrightarrow{}
  <c_1',\sigma'>}{<c_1;\mathbf{stop};c_2,\sigma> \longrightarrow{}
  <\mathbf{stop};c_2,\sigma'>}
$$
con $c_1'$ e $\sigma'$ gli stessi di prima in quanto la premessa è la
stessa. Quindi poich\'e entrambe le computazioni hanno lo stesso stato
finale $<\mathbf{noaction},\sigma'>$, la tesi
\`e vera.

\`E possibile anche dimostrare l'equivalenza usando la semantica
denotazionale, osservando che sia nella denotazione di $\mathcal{C}\llbracket
c_1;\mathbf{stop}\rrbracket$ che in quella di $\mathcal{C}\llbracket
c_1;\mathbf{stop};c_2\rrbracket$ viene prima valutato $\mathcal{C}\llbracket
c_1\rrbracket$ e poi applicato $\sigma'$ a $\mathcal{C}\llbracket
\mathbf{stop}\rrbracket$ in un caso e $\mathcal{C}\llbracket
\mathbf{stop};c_2\rrbracket$ nell'altro. In seguito l'unica differenza
\`e che nel primo caso vale subito che $\mathcal{C}\llbracket
\mathbf{stop}\rrbracket\sigma'$ \`e $<\sigma',stop>$, nel secondo caso
c'è un ulteriore passaggio in cui viene usato il secondo \emph{case}
della denotazione della sequenzializzazione e che per\`o non cambia il
risultato.


\section*{9.7}
\paragraph{Esercizio:} Estendere il linguaggio SMALL introducendo i
comandi $\mathbf{restart}$ ed $\mathbf{exit}$, il cui significato è di 
saltare rispettivamente all’inizio ed alla fine del blocco più
interno.

\paragraph{Soluzione:} Per gestire i due comandi richiesti \`e
necessario modificare il dominio:
\begin{equation*}
  \begin{multlined}  
    \mathcal{C}:Com \longrightarrow{} \mathbb{AMB}
    \longrightarrow{} \mathbb{MEM} \longrightarrow{}\\
    \qquad\qquad\qquad\qquad((\mathbb{MEM}\times\{restart, stop, normal\})+\{error\})
  \end{multlined}  
\end{equation*}

che aggiunge la possibilit\`a per i comandi di indicare il tipo di
ritorno in abbinamento al valore di ritorno della
memoria. Informalmente $normal$ indica che la valutazione del comando
che li ha ritornati
non ha portato a nessun comando di $\mathbf{stop}$ o
$\mathbf{restart}$; $stop$ e $restart$ indicano che la valutazione del
comando ha portato rispettivamente ad uno $\mathbf{stop}$ e ad un
$\mathbf{restart}$.

Per gestire il cambio di flusso del programma vengono modificate le regole di interpretazione semantica di programmi, di blocchi, e
della sequenzializzazione nel seguente modo:
\begin{align*}
  \mathcal{P}\llbracket\mathbf{program}\ c\rrbracket in\ =\ &fix(\lambda\Theta.cases
  (\mathcal{C}\llbracket c\rrbracket\rho_0(\lambda
  x.unused)[in/lin][nil/lout]) of\\
  &\qquad<\sigma,normal> : \sigma(lout);\\
  &\qquad<\sigma,stop> : \sigma(lout);\\
  &\qquad<\sigma,restart> : \Theta\\
  &endcases)
\end{align*}
\begin{align*}
  \mathcal{C}\llbracket\mathbf{begin}\ d;\ c\
  \mathbf{end}\rrbracket\rho\ =\ &fix(\lambda\Theta.\mathcal{D}\llbracket d\rrbracket\rho\
  \star\ \lambda\rho'.\mathcal{C}\llbracket c\rrbracket\rho[\rho']\
  \star\ \lambda\sigma s.\ cases\ s\ in:\\
  & \qquad normal:<\sigma,normal>;\\
  & \qquad stop:<\sigma,normal>;\\
  & \qquad restart:\Theta\\
  &endcases)
\end{align*}
\begin{align*}
  \mathcal{C}\llbracket c_1;c_2\rrbracket\rho\ =\ &\mathcal{C}\llbracket
  c_1\rrbracket\rho\ \star\ \lambda\sigma s.\ cases\ s\ in:\\
  & \qquad normal:\mathcal{C}\llbracket c_2\rrbracket\rho;\\
  & \qquad stop:<\sigma,\ stop>;\\
  & \qquad restart:<\sigma,\ restart>;\\
  & endcases
\end{align*}

Oltre a queste regole \`e necessario modificare leggermente le altre regole
di interpretazione dei comandi per dare in output la coppia $<\sigma,\
normal>$ invece della sola memoria:
\begin{align*}
  \mathcal{C}\llbracket e:=e'\rrbracket\rho\ =\ &\mathcal{E}\llbracket
  e\rrbracket\rho\ \star\ checkLOC\ \star\ \lambda
  l.\mathcal{R}\llbracket e'\rrbracket\rho\ \star\\
  &\qquad\qquad\qquad\qquad\lambda
  v\sigma.<\sigma[v/l],\ normal>
\end{align*}
\begin{align*}
  \mathcal{C}\llbracket\mathbf{while}\ e\ \mathbf{do}\ c\rrbracket\rho\
  =\ &fix(\lambda\Theta.\mathcal{R}\llbracket e\rrbracket\rho\ \star\
  checkBOOL\\
  &\qquad\qquad\star\ \lambda b.b\rightarrow\mathcal{C}\llbracket
  c\rrbracket\rho\ \star\ \Theta,\ \lambda\sigma.<\sigma,\ normal>)
\end{align*}
\begin{align*}
  \mathcal{C}\llbracket\mathbf{output}\ e\rrbracket\rho\ =\ 
  &\mathcal{R}\llbracket e\rrbracket\rho\ \star\ \lambda
  b\sigma.<\sigma[b::\sigma(lout)/lout],\ normal>
\end{align*}
Non \`e invece necessario modificare le regole per l'$\mathbf{if}$ e
per l'applicazione di procedure, in quanto la coppia viene generata a
livello superiore.

Infine \`e necessario specificare le regole di interpretazione
semantica per i due nuovi comandi $\mathbf{stop}$ e
$\mathbf{restart}$:
\begin{align*}
  \mathcal{C}\llbracket\mathbf{stop}\rrbracket\rho\ =\
  \lambda\sigma.<\sigma,\ stop>
\end{align*}
\begin{align*}
  \mathcal{C}\llbracket\mathbf{restart}\rrbracket\rho\ =\
  \lambda\sigma.<\sigma,\ restart>
\end{align*}

%\sectionline
\section*{11.10}

\section*{12.1}

\section*{12.2}
 
\end{document}

